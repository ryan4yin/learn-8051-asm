# 8051 汇编学习

看的书：《51 单片机自学笔记》，很老的书了，写得挺好的，不过使用的是 keli 语法。


## Linux 编译环境搭建

我已经很久不用 windows 写代码了，于是决定使用跨平台的 sdcc/platformio，在 linux 上写汇编。

使用基于 [platformio](https://github.com/platformio) 的开源跨平台嵌入式 IDE 开发环境。

platformio 是一个 VSCode 插件，所以先安装好 VSCode，然后直接在插件市场搜索 platformio 安装即可。

安装完成后，在侧边栏的下方就能看到一个蚂蚁头像，点击它即可进入 PlatformIO。

在创建工程的页面，PlatformIO 有提供几乎所有主流单片机平台可选，我个人目前接触到的只有 ESP32、ESP8266、Intel MSC-51(8051) 这三个平台。

创建工程时直接搜索选择 8051，platformio 会自动下载对应平台的编译调试工具链（建议使用全局代理），然后就可以玩耍啦。

### Linux 环境特定的配置

对于 Linux 环境，需要将当前用户加入到对应的序列端口读写相关的 group 中，否则浏览器或 platformio 都没权限读写 serial port.

详见：[udev-rules and groups for platformio](https://docs.platformio.org/en/latest/core/installation/udev-rules.html)

udev-rules 的配置方法请直接参考上面的链接。
group 的添加方法我简单摘抄如下，对于 arch 用户，需要执行：

```shell
sudo usermod -a -G uucp $USER
sudo usermod -a -G lock $USER
```

对于 debian/ubuntu 用户，需要执行：

```shell
sudo usermod -a -G dialout $USER
sudo usermod -a -G plugdev $USER
```

## keli 与 sdcc 的汇编兼容问题

与 keli 不同，sdcc/platformio 的汇编带了挺多 .area 相关的内容，不然编译会出问题。

这部分内容比较复杂，简单起见我直接写了个最简 c 函数编译得到了 sdcc 的 asm 模版，然后在这个模板的基础上改自己的代码...
中间遇到的一些 keli 伪指令，也是一样的玩法，参考了摇摇棒代码生成的汇编，找到了对应的 sdcc 伪指令写法。

platformio 的自动上传指令有错（详见 [platform-intel_mcs51/issues/47](https://github.com/platformio/platform-intel_mcs51/issues/47)），手动上传命令：

```
stcgal -P stc89 -p /dev/ttyUSB0 -t 11059 .pio/build/Generic8051/firmware.hex
```

我没买啥开发版，是直接玩之前买的摇摇棒电路板，用上面的指令上传固件时需要通过手动插拔电路板的 vcc 引脚线实现芯片复位。

另外还使用了 chatgpt 当汇编指令参考手册用，非常方便：

![](_img/ask-chatgpt-about-8051-asm.webp)

## 1. 控制 LED 灯

### 1.1 单个 LED 灯闪烁

51 单片机自学笔记的第一个汇编程序，改造成 sdcc 兼容格式后内容为（省略掉了 sdcc 的 asm 模板内容）：

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60
_main_loop:
	clr     _P0_0       ; P0.0 置低电平，灯亮
    mov 0x40, #0x02
	; call/scall 都仅能用于跳转到当前代码块的 label，为了跳转到外部代码块，这里必须用 lcall
	; lcall 的工作方式：首先将程序计数器 PC 当前值压栈，然后将 PC 设为目标地址再开始执行程序。等目标代码段执行完毕后再通过 ret 指令出栈恢复旧 PC
	lcall   _delay      ; 调用延时程序  
	setb    _P0_0       ; P0.0 置高电平，灯灭
    mov 0x40, #0xff
	lcall   _delay
	sjmp    _main_loop  ; 无限循环 
;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 0xff * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频（即
脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, 0x40   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

### 1.2 实现跑马灯效果

```
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0xff  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov a, 0b11011110  ; 使用累加寄存器 a 作为临时变量存储处，赋个初始值，仅 P0.7 亮
_main_loop:
	mov _P0, a          ; 使用 a 中的值来控制 P0 的所有引脚
    rl a                ; rotate left，即向左滚动移位，特点是会使用高位的 bit 来补低位，就像一个轮子一样滚动，刚好达成了跑马灯的效果
	lcall   _delay      ; 调用延时程序

	sjmp    _main_loop  ; 无限循环 
;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 0xff * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频（即
脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, 0x40   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

### 1.3 通过常量数据实现任意 LED 灯闪烁程序

```
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0xff  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov r2, #0x00  ; 使用寄存器 r2 作为临时变量存储处。这里不能用 a 了，因为后面做算术操作必须用到 a
_main_loop:
	mov a, r2
    mov dptr, #_tab     ; 给 dptr 数据指针赋 #_tab 的地址
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中
    mov _P0, a          ; 将 a 中的数据送 P0 显示，这样就实现了使用 #_tab 中存储的数据来“动态”显示的效果
	lcall   _delay      ; 调用延时程序

    inc r2                      ; r2 变量自增 1，这样下次循环将显示下一个地址中存储的数据
    cjne r2, #73, _main_loop    ; 如果 r2 不等于一个整数，就继续循环。这个整数是你 _tab 数据区的数据量，写大了会导致指针越界，读到的就不知道是啥数据了
    mov r2, #0x00               ; 重置寄存器 r2，重新从头开始显示

	sjmp    _main_loop  ; 无限循环
;------------------------------------------------------------
; 常量数据区，当前数据量 12
;------------------------------------------------------------
_tab:
	.db #0b11111110
	.db #0b11111101
	.db #0b11111011
	.db #0b11110111
	.db #0b11101111
	.db #0b11011111
	.db #0b10111111
	.db #0b01111111
	.db #0b10111111
	.db #0b11011111
	.db #0b11101111
	.db #0b11110111
	.db #0b11111011
	.db #0b11111101
	.db #0b11111110
	.db #0b00000000
	.db #0b00000000
	.db #0b11111111
	.db #0b11111111
	.db #0b00000000
	.db #0b00000000
	.db #0b11111111
	.db #0b11111111
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b01010101
	.db #0b01010101
	.db #0b00000000
	.db #0b00000000
	.db #0b01010101
	.db #0b01010101
	.db #0b00000000
	.db #0b00000000
	.db #0b10101010
	.db #0b10101010
	.db #0b00000000
	.db #0b00000000
	.db #0b10101010
	.db #0b10101010
	.db #0b00000000
	.db #0b00000000
;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 0xff * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频（即
脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, 0x40   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

