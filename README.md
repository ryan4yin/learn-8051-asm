# 8051 汇编学习

看的书：《51 单片机自学笔记》，很老的书了，写得挺好的，不过使用的是 keli 语法。

[TOC]

## Linux 编译环境搭建

我已经很久不用 windows 写代码了，于是决定使用跨平台的 sdcc/platformio，在 linux 上写汇编。

使用基于 [platformio](https://github.com/platformio) 的开源跨平台嵌入式 IDE 开发环境。

platformio 是一个 VSCode 插件，所以先安装好 VSCode，然后直接在插件市场搜索 platformio 安装即可。

安装完成后，在侧边栏的下方就能看到一个蚂蚁头像，点击它即可进入 PlatformIO。

在创建工程的页面，PlatformIO 有提供几乎所有主流单片机平台可选，我个人目前接触到的只有 ESP32、ESP8266、Intel MSC-51(8051) 这三个平台。

创建工程时直接搜索选择 8051，platformio 会自动下载对应平台的编译调试工具链（建议使用全局代理），然后就可以玩耍啦。

### Linux 环境特定的配置

对于 Linux 环境，需要将当前用户加入到对应的序列端口读写相关的 group 中，否则浏览器或 platformio 都没权限读写 serial port.

详见：[udev-rules and groups for platformio](https://docs.platformio.org/en/latest/core/installation/udev-rules.html)

udev-rules 的配置方法请直接参考上面的链接。
group 的添加方法我简单摘抄如下，对于 arch 用户，需要执行：

```shell
sudo usermod -a -G uucp $USER
sudo usermod -a -G lock $USER
```

对于 debian/ubuntu 用户，需要执行：

```shell
sudo usermod -a -G dialout $USER
sudo usermod -a -G plugdev $USER
```

## keli 与 sdcc 的汇编兼容问题

与 keli 不同，sdcc/platformio 的汇编带了挺多 .area 相关的内容，不然编译会出问题。

这部分内容比较复杂，简单起见我直接写了个最简 c 函数编译得到了 sdcc 的 asm 模版，然后在这个模板的基础上改自己的代码...
中间遇到的一些 keli 伪指令，也是一样的玩法，参考了摇摇棒代码生成的汇编，找到了对应的 sdcc 伪指令写法。

platformio 的自动上传指令有错（详见 [platform-intel_mcs51/issues/47](https://github.com/platformio/platform-intel_mcs51/issues/47)），手动上传命令：

```
stcgal -P stc89 -p /dev/ttyUSB0 -t 11059 .pio/build/Generic8051/firmware.hex
```

我没买啥开发版，是直接玩之前买的摇摇棒电路板，用上面的指令上传固件时需要通过手动插拔电路板的 vcc 引脚线实现芯片复位。

另外还使用了 chatgpt 当汇编指令参考手册用，非常方便：

![](_img/ask-chatgpt-about-8051-asm.webp)

## 1. 控制 LED 灯

### 1.1 单个 LED 灯闪烁

51 单片机自学笔记的第一个汇编程序，改造成 sdcc 兼容格式后内容为（省略掉了 sdcc 的 asm 模板内容）：

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60
_main_loop:
	clr     _P0_0       ; P0.0 置低电平，灯亮
    mov 0x40, #0x02
	; call/scall 都仅能用于跳转到当前代码块的 label，为了跳转到外部代码块，这里必须用 lcall
	; lcall 的工作方式：首先将程序计数器 PC 当前值压栈，然后将 PC 设为目标地址再开始执行程序。等目标代码段执行完毕后再通过 ret 指令出栈恢复旧 PC
	lcall   _delay      ; 调用延时程序  
	setb    _P0_0       ; P0.0 置高电平，灯灭
    mov 0x40, #0xff
	lcall   _delay
	sjmp    _main_loop  ; 无限循环 
;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

### 1.2 实现跑马灯效果

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0xff  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov a, 0b11011110  ; 使用累加寄存器 a 作为临时变量存储处，赋个初始值，仅 P0.7 亮
_main_loop:
	mov _P0, a          ; 使用 a 中的值来控制 P0 的所有引脚
    rl a                ; rotate left，即向左滚动移位，特点是会使用高位的 bit 来补低位，就像一个轮子一样滚动，刚好达成了跑马灯的效果
	lcall   _delay      ; 调用延时程序

	sjmp    _main_loop  ; 无限循环 
;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

### 1.3 通过常量数据实现任意 LED 灯闪烁程序

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0xff  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov r2, #0x00  ; 使用寄存器 r2 作为临时变量存储处。这里不能用 a 了，因为后面做算术操作必须用到 a
_main_loop:
	mov a, r2
    mov dptr, #_tab     ; 给 dptr 数据指针赋 #_tab 的地址
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中
    mov _P0, a          ; 将 a 中的数据送 P0 显示，这样就实现了使用 #_tab 中存储的数据来“动态”显示的效果
	lcall   _delay      ; 调用延时程序

    inc r2                      ; r2 变量自增 1，这样下次循环将显示下一个地址中存储的数据
    cjne r2, #73, _main_loop    ; 如果 r2 不等于一个整数，就继续循环。这个整数是你 _tab 数据区的数据量，写大了会导致指针越界，读到的就不知道是啥数据了
    mov r2, #0x00               ; 重置寄存器 r2，重新从头开始显示

	sjmp    _main_loop  ; 无限循环
;------------------------------------------------------------
; 常量数据区，当前数据量 12
;------------------------------------------------------------
_tab:
	; 由高位到低位，8 个 bit 分别对应 P0.7 到 P0.0 八个引脚
	.db #0b11111110
	.db #0b11111101
	.db #0b11111011
	.db #0b11110111
	.db #0b11101111
	.db #0b11011111
	.db #0b10111111
	.db #0b01111111
	.db #0b10111111
	.db #0b11011111
	.db #0b11101111
	.db #0b11110111
	.db #0b11111011
	.db #0b11111101
	.db #0b11111110
	.db #0b00000000
	.db #0b00000000
	.db #0b11111111
	.db #0b11111111
	.db #0b00000000
	.db #0b00000000
	.db #0b11111111
	.db #0b11111111
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b11110000
	.db #0b11110000
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b00001111
	.db #0b00001111
	.db #0b00000000
	.db #0b00000000
	.db #0b01010101
	.db #0b01010101
	.db #0b00000000
	.db #0b00000000
	.db #0b01010101
	.db #0b01010101
	.db #0b00000000
	.db #0b00000000
	.db #0b10101010
	.db #0b10101010
	.db #0b00000000
	.db #0b00000000
	.db #0b10101010
	.db #0b10101010
	.db #0b00000000
	.db #0b00000000
;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

## 2. 控制 LED 数码管

八段 LED 数码管是由 8 个发光二极管组成。其中 7 个长条形的发光管排列成一个“日”
字形，另一个圆点形的发光管在显示器的右下角用于显示小数点。它能显示各种数字
及部份英文字母。

LED 数码管有两种不同的连接形式：

- 共阳极 LED 显示器
  - 结构：8 个发光二极管的正极连在一起，负极则各自独立。
  - 使用方法：公共阳极接+5V；这时阴极接低电平的发光二极管就导通点亮，接高电平的则不亮。
- 共阴极 LED 显示器
  - 结构：8 个发光二极管的负极连在一起，正极则各自独立。
  - 使用方法：公共阴极接地，这时阳极接高电平的发光二极管就导通点亮，接低电平的则不亮。

驱动电路中的限流电阻 R 通常根据 LED 的工作电流计算得到。R=(VCC—VLED)/ILED，式中 VCC 为电源电压（+5V），VLED 为 LED 压降（约为 2V），ILED 为工作电流（一般可取 1～20mA），
R 通常为几百欧姆。

一般 LED 数码管工作时的电流在 10mA 左右亮度比较适中，而包括 51 在内的大部分单片机的 I/O 口的灌电流输出能力都比较强，拉电流能力则较弱。

因此单片机可以直接驱动共阳极的 LED 数码管，而比较难直接驱动共阴极的 LED 数码管，如果一定要用共阴极 LED 数码管可以另加驱动电路。

这里有两个新名词「灌电流」与「拉电流」。简单解释下，单片机的拉电流和灌电流都是对单片机的输出而言的，是单片机驱动能力的具体体现：

- 如果电路工作时，单片机引脚处于低电平，电流从外部电路流入引脚，则称这种情况为「灌电流」
- 相反如果电路工作时，单片机引脚处于高电平，电路从单片机引脚拉出电流（或者说电流从引脚流入电路），则称这种情况下「拉电流」。

有必要再复习一下我使用的 AT89S52 引脚图：

![](_img/AT89S52-pinout.png)

然后再看下 4 位数码管的引脚图：

![](_img/8-segment-display_4_numbers.jpg)

- 图中给出了 abcdefg 7 个引脚以及小数点引脚 dp，与数码管每一段的对应关系。
- D1 到 D4 这 4 个引脚，分别为 D1 到 D4 四个数码管的公共极。这里我用的是共阳极数码管，所以它们都是阳极，得接 5V 电源正极。

可以看到 4 个数码的 8 个输入引脚是共用的，那该如何控制它们同时显示不同的内容呢？
实际上靠的就是人眼的视觉暂留效应，通过 D1 - D4 这 4 个阳极电压的高低来分别控制 4 个数码管的亮灭，每次都让 4 个数码管分别显示内容即可。

### 2.1 控制单个数码管显示数字

基于前面的任意 LED 闪烁程序改一改，就得到了如下这个程序，它控制单个数码管依次循环显示 0-9 这几个数字。

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0xff  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov r2, #0x00  ; 使用寄存器 r2 作为临时变量存储处。这里不能用 a 了，因为后面做算术操作必须用到 a
_main_loop:
	mov a, r2
    mov dptr, #_tab     ; 给 dptr 数据指针赋 #_tab 的地址
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中
    mov _P0, a          ; 将 a 中的数据送 P0 显示，这样就实现了使用 #_tab 中存储的数据来“动态”显示的效果
	lcall   _delay      ; 调用延时程序 * 4
	lcall   _delay 
	lcall   _delay
	lcall   _delay

    inc r2                      ; r2 变量自增 1，这样下次循环将显示下一个地址中存储的数据
    cjne r2, #10, _main_loop    ; 如果 r2 不等于一个整数，就继续循环。这个整数是你 _tab 数据区的数据量，写大了会导致指针越界，读到的就不知道是啥数据了
    mov r2, #0x00               ; 重置寄存器 r2，重新从头开始显示

	sjmp    _main_loop  ; 无限循环
;------------------------------------------------------------
; 常量数据区，当前数据量 12
;------------------------------------------------------------
_tab:
	; 由高位到低位，8 个 bit 分别对应 P0.7 到 P0.0 八个引脚
	; 这里 dp 与 gfedcba 八个数码管引脚（倒排序），分别接到 P0.0 ~ P0.7 上

	; 按顺序显示 0-9 这几个数字，dp 暂时未用上，小数点全程都不亮
	.db #0b11000000 ; dp 与 g 灭，显示 0
	.db #0b11111001 ; 仅 bc 亮，显示 1
	.db #0b10100100 ; 仅 cf 灭，显示 2
	.db #0b10110000 ; 仅 ef 灭，显示 3
	.db #0b10011001 ; 仅 ade 灭，显示 4
	.db #0b10010010 ; 仅 be 灭，显示 5
	.db #0b10000010 ; 仅 b 灭，显示 6
	.db #0b11111000 ; defg 灭，显示 7
	.db #0b10000000 ; 全部亮，显示 8
	.db #0b10010000 ; 仅 e 灭，显示 9
	.db #0b11111111 ; 全部灭，不显示

;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

### 2.2 控制 4 个数码管显示 2023

利用人眼视觉暂留效应，用 4 个数码管显示 2023 这个数字：

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0x0f  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov _P2, #0b00000000   ; P2 全置为低电平，这样 D1 - D4 四个数码管对应 NPN 三极管的 B 基极都为低电平，CE 两极都不导通。
_main_loop:
    mov _P0, #0b10100100 ; 仅 cf 灭，显示 2
	setb _P2_0           ; 给 D1 供电
	lcall   _delay
	clr _P2_0          ; 关掉 D1 电源

    mov _P0, #0b11000000 ; dp 与 g 灭，显示 0
	setb _P2_1           ; 给 D2 供电
	lcall   _delay
	clr _P2_1          ; 关掉 D2 电源

    mov _P0, #0b10100100 ; 仅 cf 灭，显示 2
	setb _P2_2           ; 给 D3 供电
	lcall   _delay
	clr _P2_2          ; 关掉 D3 电源

    mov _P0, #0b10110000 ; 仅 ef 灭，显示 3
	setb _P2_3           ; 给 D4 供电
	lcall   _delay
	clr _P2_3          ; 关掉 D4 电源

	sjmp    _main_loop    ; 无限循环

;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

### 2.3 控制 4 个数码管显示任意数字

这里我们实现了一个 display 函数，它可显示任意数字，然后实现了一个自增计数器来使数码管显示 0 - 99 自增。

但是这段代码是串行执行的，每次显示都会更新一次计数器，这就导致如果想看到明显的自增效果，就需要在两次自增/显示之间加较大的 delay 延时，结果就是看上去两个数值无法同时显示了。

我们将在后面解决这个问题。

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
; 自定义的全局变量
; 包括代码段 label 也需要使用这种伪指令定义
;--------------------------------------------------------
	.globl _delay
	.globl _main
	.globl _display

	.globl COUNT  ; 自增变量，每次 + 1
	.globl LED3   ; 第三个数码管显示数值存放处
	.globl LED4
	
	COUNT = 0x30
	LED3 = 0x31
	LED4 = 0x32
	
;--------------------------------------------------------
; Home
;--------------------------------------------------------
	.area HOME    (CODE)
	.area HOME    (CODE)
__sdcc_program_startup:
	ljmp	_main
;	return from main will return to caller
;--------------------------------------------------------
; code
;--------------------------------------------------------
	.area CSEG    (CODE)
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0xff  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov _P2, #0b00000000   ; P2 全置为高电平，D1 - D4 四个数码管都没电压

    mov dptr, #_tab     ; 给 dptr 数据指针赋 #_tab 的地址
	mov COUNT, #0x0     ; 清零
	mov LED3,  #0x0     ; 清零
	mov LED4,  #0x0     ; 清零

_main_loop:
	lcall _update
	lcall _display

	sjmp    _main_loop  ; 无限循环

_update:
	inc COUNT           ; 计数器 +1
	mov a, COUNT
	cjne a, #100, _continue  ; 如果 COUNT 不为 100，就进入普通逻辑
	mov COUNT, #0x0     ; COUNT 到 100 了，将它清零
	_continue:
		mov a, COUNT
		mov b, #10
		div ab           ; （无符号除法）用 a 除以 b，结果存到 a 中，余数存到 b 中
		mov LED3, a     ; 十位数用 LED3 显示
		mov LED4, b     ; 个位数用 LED4 显示

		ret							
	  
_display:
	mov a, LED3         ; 将 LED3 中的值 copy 到寄存器 a 中作为索引值
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中

    mov _P0, a ; a 中的值，即为以 LED3 作为索引拿到的对应数码管引脚数据
	setb _P2_2          ; 给 D3 供电
	lcall   _delay
	clr _P2_2           ; 关掉 D3 电源

	mov a, LED4         ; 将 LED3 中的值 copy 到寄存器 a 中作为索引值
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中
    mov _P0, a
	setb _P2_3          ; 给 D4 供电
	lcall   _delay
	clr _P2_3           ; 关掉 D4 电源

	ret                 ; 跳转回调用方
;------------------------------------------------------------
; 常量数据区，当前数据量 10
;------------------------------------------------------------
_tab:
	; 由高位到低位，8 个 bit 分别对应 P0.7 到 P0.0 八个引脚
	; 这里 dp 与 gfedcba 八个数码管引脚（倒排序），分别接到 P0.0 ~ P0.7 上

	; 从索引 0 到索引 9，存储的分别是数字 0-9 对应的 P0 引脚数据值
	.db #0b11000000 ; dp 与 g 灭，显示 0
	.db #0b11111001 ; 仅 bc 亮，显示 1
	.db #0b10100100 ; 仅 cf 灭，显示 2
	.db #0b10110000 ; 仅 ef 灭，显示 3
	.db #0b10011001 ; 仅 ade 灭，显示 4
	.db #0b10010010 ; 仅 be 灭，显示 5
	.db #0b10000010 ; 仅 b 灭，显示 6
	.db #0b11111000 ; defg 灭，显示 7
	.db #0b10000000 ; 全部亮，显示 8
	.db #0b10010000 ; 仅 e 灭，显示 9

;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

## 2.3. 使用按键控制计数器自增

这里的重点在于，按键触发的电平不是理想的矩形波，在按下与松开按键的前后，都会存在电压抖动。如果不考虑到这一点，设计出来的程序将会出现无法触发、重复触发等玄学 bug！

常用的解决方法是「软件去抖法」，即在程序第一次检测出某个端口上接的按键被按下时，不是马上确认为按键按下，而是先调一个约为 10ms 的延时。
等闭合抖动结束后再次检测该端口是否仍然为按键按下的状态，如果是则认为真的有按键被按下，然后等待按键释放，按键释放后对相应的按键标志进行置位，即做个记号表示某个按键按下过；
如果经过刚才那 10ms 延时后，检测端口不是处于按键按下的状态，则认为是按键误触发或当成干扰等不予理会。

这里使用了 P1.4 引脚来接按键，另一边直接接地。如果按键按下，P1.4 就会变成低电平，读数会变成 0，否则读数应该是 1.

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
; 自定义的全局变量
; 包括代码段 label 也需要使用这种伪指令定义
;--------------------------------------------------------
	.globl _delay
	.globl _main
	.globl _display
	.globl _check_key

	.globl COUNT  ; 自增变量，每次 + 1
	.globl LED3   ; 第三个数码管显示数值存放处
	.globl LED4
	
	COUNT = 0x30
	LED3 = 0x31
	LED4 = 0x32
	
;--------------------------------------------------------
; Home
;--------------------------------------------------------
	.area HOME    (CODE)
	.area HOME    (CODE)
__sdcc_program_startup:
	ljmp	_main
;	return from main will return to caller
;--------------------------------------------------------
; code
;--------------------------------------------------------
	.area CSEG    (CODE)
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0x11  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov _P2, #0b00000000   ; P2 全置为高电平，D1 - D4 四个数码管都没电压

    mov dptr, #_tab     ; 给 dptr 数据指针赋 #_tab 的地址
	mov COUNT, #0x0     ; 清零
	mov LED3,  #0x0     ; 清零
	mov LED4,  #0x0     ; 清零

_main_loop:
	lcall _check_key
	sjmp    _main_loop  ; 无限循环


_check_key:
	jnb _P1_4, _pressed     ; 按键处于低电平（0），说明被按下了
	_check_key_ret:
		lcall _display
		ret                 ; 按键未被按下，直接返回
	_pressed:
		lcall _delay
		jb _P1_4, _check_key_ret    ; 按键处于高电平（1），说明未被按下
	_check_key_wait:
		lcall _display
		jnb _P1_4, _check_key_wait  ; 按键仍处于低电平（0），等待按键释放
		lcall _inc_count            ; 按键已释放，count 自增
		ret


_inc_count:
	inc COUNT           ; 计数器 +1
	mov a, COUNT
	cjne a, #100, _continue  ; 如果 COUNT 不为 100，就进入普通逻辑
	mov COUNT, #0x0     ; COUNT 到 100 了，将它清零
	_continue:
		mov a, COUNT
		mov b, #10
		div ab           ; （无符号除法）用 a 除以 b，结果存到 a 中，余数存到 b 中
		mov LED3, a     ; 十位数用 LED3 显示
		mov LED4, b     ; 个位数用 LED4 显示

		ret							

_display:
	mov a, LED3         ; 将 LED3 中的值 copy 到寄存器 a 中作为索引值
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中

    mov _P0, a ; a 中的值，即为以 LED3 作为索引拿到的对应数码管引脚数据
	setb _P2_2          ; 给 D3 供电
	lcall   _delay
	clr _P2_2           ; 关掉 D3 电源

	mov a, LED4         ; 将 LED3 中的值 copy 到寄存器 a 中作为索引值
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中
    mov _P0, a
	setb _P2_3          ; 给 D4 供电
	lcall   _delay
	clr _P2_3           ; 关掉 D4 电源

	ret                 ; 跳转回调用方
;------------------------------------------------------------
; 常量数据区，当前数据量 10
;------------------------------------------------------------
_tab:
	; 由高位到低位，8 个 bit 分别对应 P0.7 到 P0.0 八个引脚
	; 这里 dp 与 gfedcba 八个数码管引脚（倒排序），分别接到 P0.0 ~ P0.7 上

	; 从索引 0 到索引 9，存储的分别是数字 0-9 对应的 P0 引脚数据值
	.db #0b11000000 ; dp 与 g 灭，显示 0
	.db #0b11111001 ; 仅 bc 亮，显示 1
	.db #0b10100100 ; 仅 cf 灭，显示 2
	.db #0b10110000 ; 仅 ef 灭，显示 3
	.db #0b10011001 ; 仅 ade 灭，显示 4
	.db #0b10010010 ; 仅 be 灭，显示 5
	.db #0b10000010 ; 仅 b 灭，显示 6
	.db #0b11111000 ; defg 灭，显示 7
	.db #0b10000000 ; 全部亮，显示 8
	.db #0b10010000 ; 仅 e 灭，显示 9

;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, 0x40       ; 从 RAM 0x40 位置取值，赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```

## 3. 定时器/计数器与中断

单片机内部有数字电路，可以通过数脉冲信号的方式来实现计时或计数。
如果这个电路数的是晶振产生的信号，那就能计时。
而如果这个电路数的是其他引脚输入的脉冲信号，那就可用于计数。

对于我们现在使用 12M 晶振的场景，内部数字电路会将脉冲信号 12 分频后（即脉冲变宽，频率为晶振频率的十二分之一）提供给定时器，也即每个脉冲的时间间隔为 1M 也就是 1 微秒。
定时器每次收到脉冲信号就会把计数加个 1. 当把装这个数的容器加满了，会自动有一个标志位从 0 变成 1，表明发生了溢出。

定时器/计数器的数据存放在 T0 与 T1 两组 16 位地址中，它们的结构与命名如下：

| TH0/1(高8位) | TL0/1(低8位) |
| ---------- | ---------- |
| D15 D14 D13 D12 D11 D10 D9 D8 | D7 D6 D5 D4 D3 D2 D1 D0 |

能看到可以用 TH0 或者 TL0 来访问地址的高 8 位与低 8 位，T1 也一样。

定时器/计数器既可用于定时也可用于计数，实际的工作方式是通过工作方式寄存器 TMOD 的值控制的。（这个寄存器的名字应该是 Time Mode 的缩写）

TMOD 的高四位用于控制 T1，低 4 位用于控制 T0，T0 与 T1 的参数完全类似。

| T1 工作方式字段 |     |    |    | T0 工作方式字段 |     |    |    |
| --------- | --- | -- | -- | --------- | --- | -- | -- |
| D7        | D6  | D5 | D4 | D3        | D2  | D1 | D0 |
| GATE      | C/T | M1 | M0 | GATE      | C/T | M1 | M0 |

1. GATE 位
   1. GATE=0 时，定时器/计数器只受 TCON 寄存器中的 TR0 位控制，TR0=0 时定时器/计数器 T0 停止工作，而当 TR0=1 时定时器/计数器 T0 开始工作。
   2. GATE=1 时，定时器/计数器同时受 TCON 寄存器中的 TR0 位、以及单片机外部引脚 P3.2 的控制。仅当 P3.2 引脚为高电平且 TR0=1 这两个条件同时满足时定时器/计数器 T0 才工作。一般这种用法通常用来测量 P3.2 引脚上正脉冲的宽度。
2. C/T 位
   1. 决定 定时器/计数器 工作在定时模式还是计数模式
   2. 当 C/T=0 时，T0 工作在定时方式，此时由 TH0 和 TL0 组成的 16 位计数容器，这个容器会对晶振产生的脉冲再 12 分频后的脉冲进行计数。
      1. 如果单片机外部接的是 12M 晶振，则 TH0 和 TL0 组成的 16 位计数容器中的数据就会每隔 1 微妙自动加 1
   3. 当 C/T=1 时，T0 工作在计数方式，由 TH0 和 TL0 组成的 16 位计数容器会对从单片机外部引脚 P3.4 输入单片机的脉冲进行计数（对于 T1 而言这个外部引脚则是 P3.5），每输入一个脉冲，则 TH0 和 TL0 组成的 16 位计数容器中的数据会自动加 1。
3. M1/M0
   1. 这两个比特位的 4 种组合，用于控制 T0 的 16 位计数容器中计数的变化规律
   2. M1/M0 为 0x00: 此时 TH0 和 TL0 构成 13 位计数容器，TL0 的高 3 位不可用，计数范围 0～8191
   3. M1/M0 为 0x01: 此时 TH0 和 TL0 构成 16 位计数容器，计数范围 0～65535
   3. M1/M0 为 0x10: 
      1. TH0 和 TL0 成为两个 8 位计数器，TH0 中的数据固定为开始设定的值不变，TL0中数据按晶振 12 分频后速度自动加 1 至溢出，TH0 中数据自动拷贝给 TL0，在此基础上自加，TL0 如此循环自加
      2. 一般在将 MCU 用做串行通讯波特率发生器时，会用到此模式
   4. M1/M0 为 0x11: 此时 T0 的 TH0 和 TL0 成为两个独立的 8 位计数器，且 TH0 只能用于定时；TL0 可以用于定时也可以用于计数
      1. 只有 T0 可用于本模式，T1 不可以


>注意：TMOD 寄存器上不能使用 clr/setb 等位操作指令，只能使用 mov 指令赋值

前面讲 GATE 时还提到了一个 TCON 寄存器（这个寄存器的名字应该是 Time Control 的缩写），其结构如下：

| 用于控制 T1 |     | 用于控制 T0 |     | 控制外中断 1 |     | 控制外中断 0 |     |
| ------- | --- | ------- | --- | ------- | --- | ------- | --- |
| D7      | D6  | D5      | D4  | D3      | D2  | D1      | D0  |
| TF1     | TR1 | TF0     | TR0 | IE1     | IT1 | IE0     | IT0 |


1. TR0: 功能前面已经介绍过了，用于控制定时器/计数器工作
2. TF0: 一个溢出标志位，如果定时器/计数器 T0 装数的容器发生溢出时它会被置为 1，这个标志位需要用户手动清零。

TR1/TF1 跟 TR0/TF0 的功能完全一致，区别是它们是控制 T1 的。

而后面四个外中断控制位，则是用于控制外中断的。
外中断是指，当中断控制引脚发生电位变化时，MCU 将会打断当前正在执行的代码，跳转到中断函数中进行中断处理，中断处理完成后再回到之前打断的地方继续执行。

外中断的电位变化信号具体来说有两种：

- **低电平信号**：只要检测到是低电平就触发中断，如果一直维持在低电平就会一直触发
  - 低电平信号不会锁存，所以如果 CPU 处理不及时就可能漏掉信号
- **下降沿信号**: 指高电平转低电平的这一瞬间。
  - 下降沿触发是锁存中断信号的，由 D 触发器记忆，所以即使 CPU 未及时响应，信号已经消失了，该中断仍然有效。

TCON 中几个外中断控制位说明如下：

- IT0/IT1 中断信号类型控制位
	- 当 IT0=1(setb IT0) 时，只有当 P3.2 引脚出现下降沿时才会会产生一次中断。
	- 当 IT0=0(CLR IT0) 时，表示当 P3.2 引脚只要出现低电平就会一直频繁的产生中断。
	- IT1 则对应 P3.3 引脚，功能完全一样
- IE0/IE1
  - IE0 位是 P3.2 引脚产生中断时的一个标志位，当产生中断时该位自动由硬件置 1，在 CPU 响应中断后，硬件会自动将其置为 0

8051 系列单片机有 5 个事件可以中断单片机正在执行的主程序，这些中断对应的跳转地址都是固定的，分别为：

 打断主程序的“人”——中断源（优先级由高至低排序） | 中断入口地址 | 中断发生标志     |
| ------------------------- | ------ | ---------- |
| 引脚P3.2上的低电平或下降沿信号         | 0x0003 | TCON中IE0位（外中断 0）  |
| 定时器/计数器T0计数容器溢出           | 0x000b | TCON中TF0位  |
| 引脚P3.3上的低电平或下降沿信号         | 0x0013 | TCON中IE1位（外中断 1）  |
| 定时器/计数器T1计数容器溢出           | 0x001b | TCON中TF1位  |
| 串行口发送或接收完一个字节数据           | 0x0023 | SCON中TI或RI |

所有的中断都受中断允许寄存器 IE 的控制，它的结构如下：

| D7 | D6 | D5  | D4 | D3  | D2  | D1  | D0  |
| -- | -- | --- | -- | --- | --- | --- | --- |
| EA | 空  | ET2 | ES | ET1 | EX1 | ET0 | EX0 |


- EA: 总中断允许控制位
  - EA 就相当于每家水管的总闸。如果总闸不开，各个水龙头即使开了也不会有水。
- EX0/EX1: 外中断 0 跟外中断 1 的允许控制位
  - 就相当于家里每个水龙头的开关，也即水管的分闸。
  - 外中断 0 对应 MCU 的 P3.2 引脚，外中断 1 对应 MCU 的 P3.3 引脚
- ET0/ET1: 定时器/计数器溢出中断的允许控制位
  - 也是一个水龙头，分别控制 T0/T1 发生溢出时，是否能够触发中断。
- ES: 串口中断允许控制位
  - 在串口发送完或接收完一个字节数据时，是否能够触发中断


### 3.1 使用定时器与中断实现按秒自增

在前面数码管通过按键自增的基础上进行修改，将按键触发改为定时器 + 中断触发，实现按秒自增。

要注意的是，sdcc 的中断定义方法与 keli 区别较大

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
; interrupt vector 
;--------------------------------------------------------
	.area HOME    (CODE)
__interrupt_vect:
	ljmp	__sdcc_gsinit_startup  ; 一条指令 2 字节
	.ds 8                          ; 中间留空 8 字节
	ljmp _interrupt_handler_t0     ; 这条指令从中断表的第 11 字节开始，地址为 0x0000b，即 t0 溢出中断的跳转地址

;--------------------------------------------------------
; global & static initialisations
;--------------------------------------------------------
	.area HOME    (CODE)
	.area GSINIT  (CODE)
	.area GSFINAL (CODE)
	.area GSINIT  (CODE)
	.globl __sdcc_gsinit_startup
	.globl __sdcc_program_startup
	.globl __start__stack
	.globl __mcs51_genXINIT
	.globl __mcs51_genXRAMCLEAR
	.globl __mcs51_genRAMCLEAR
	.area GSFINAL (CODE)
	ljmp	__sdcc_program_startup
;--------------------------------------------------------
; 自定义的全局变量
; 包括代码段 label 也需要使用这种伪指令定义
;--------------------------------------------------------
.globl _delay
.globl _main
.globl _display
.globl _interrupt_handler_t0

.globl COUNT  ; 自增变量，每次 + 1
.globl T_COUNT  ; 用于定时的自增变量
.globl LED3   ; 第三个数码管显示数值存放处
.globl LED4

COUNT = 0x30
T_COUNT = 0x31
LED3 = 0x32
LED4 = 0x33

;--------------------------------------------------------
; Home
;--------------------------------------------------------
	.area HOME    (CODE)
	.area HOME    (CODE)
__sdcc_program_startup:
	ljmp	_main
;	return from main will return to caller
;--------------------------------------------------------
; code
;--------------------------------------------------------
	.area CSEG    (CODE)
;--------------------------------------------------------
;	 function main
;--------------------------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
;--------------------------------------------------------
;	 我们的自定义程序内容由此开始，前面的都是 sdcc 模板内容
;--------------------------------------------------------
    ; 单片机默认会给堆栈分配一个起始地址为 07H，而内存 RAM 中的 07H 这个地方是第 0 组工作寄存器 R7 的空间
    ; 如果你既用了工作寄存器又向堆栈中存储数据，这样在一个地方存放不同的数据，就会导致一些数据被覆盖，从而导致程序莫名其妙的不正常
    ; 在手写汇编时为了避免错误，通常在初始化阶段使用如下命令手动将堆栈指针移动到 0x60
    ; 注意 #0x60 表示这个字面量数字，而如果去掉 # 则表示 RAM 对应地址存放的值
    mov sp, #0x60

    mov 0x40, #0x0  ; 延时函数的参数
    mov _P0, #0b11111111   ; P0 全置为高电平，即 P0 上的灯全灭
    mov _P2, #0b00000000   ; P2 全置为高电平，D1 - D4 四个数码管都没电压

    mov dptr, #_tab     ; 给 dptr 数据指针赋 #_tab 的地址
	mov COUNT, #0x0     ; 清零
	mov T_COUNT, #0x0     ; 清零
	mov LED3,  #0x0     ; 清零
	mov LED4,  #0x0     ; 清零

	mov _TH0, #0x3c     ; 给 T0 赋值 0x3cb0，即 65535 - 50000，使其定时 50ms 后触发溢出中断
	mov _TL0, #0xb0

	mov TMOD, #0b00000001  ; C/T位设置为 0, M1M0设置位 0x01，即模式1，16 位定时
	mov TCON, #0b0010000  ; TR0设置为1，即启动定时器0开始工作
	setb ET0             ; IE中的ET0位设置为1，开定时器中断0
	setb EA              ; IE中的EA位设置为1，开总中断

_main_loop:
	lcall _display
	sjmp    _main_loop  ; 无限循环


_interrupt_handler_t0:
	inc T_COUNT           ; 计数器 +1
	mov a, T_COUNT
	cjne a, #20, _continue_t0  ; 如果 T_COUNT 不为 20（50000 us * 20 刚好为 1 秒），就进入普通逻辑
	mov T_COUNT, #0x0     ; T_COUNT 到 20 了，将它清零
	lcall _inc_count  ; 显示器的秒数 + 1
	_continue_t0:
		mov _TH0, #0x3c   ; 给 T0 赋值 0x3cb0，即 65535 - 50000，使其定时 50ms 后触发溢出中断
		mov _TL0, #0xb0
		reti              ; 中断程序要使用 reti 返回
_inc_count: 
	inc COUNT           ; 计数器 +1
	mov a, COUNT
	cjne a, #100, _continue_inc  ; 如果 COUNT 不为 100，就进入普通逻辑
	mov COUNT, #0x0     ; COUNT 到 100 了，将它清零
	_continue_inc:
		mov a, COUNT
		mov b, #10
		div ab           ; （无符号除法）用 a 除以 b，结果存到 a 中，余数存到 b 中
		mov LED3, a     ; 十位数用 LED3 显示
		mov LED4, b     ; 个位数用 LED4 显示

		ret							

_display:
	mov a, LED3         ; 将 LED3 中的值 copy 到寄存器 a 中作为索引值
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中

    mov _P0, a ; a 中的值，即为以 LED3 作为索引拿到的对应数码管引脚数据
	setb _P2_2          ; 给 D3 供电
	lcall   _delay
	clr _P2_2           ; 关掉 D3 电源

	mov a, LED4         ; 将 LED3 中的值 copy 到寄存器 a 中作为索引值
    movc a, @a+dptr     ; A 和 DPTR 中的数加一起作为地址，把此地址中的数据（1 byte）取出来再存到 A 中
    mov _P0, a
	setb _P2_3          ; 给 D4 供电
	lcall   _delay
	clr _P2_3           ; 关掉 D4 电源

	ret                 ; 跳转回调用方

;------------------------------------------------------------
; 常量数据区，当前数据量 10
;------------------------------------------------------------
_tab:
	; 由高位到低位，8 个 bit 分别对应 P0.7 到 P0.0 八个引脚
	; 这里 dp 与 gfedcba 八个数码管引脚（倒排序），分别接到 P0.0 ~ P0.7 上

	; 从索引 0 到索引 9，存储的分别是数字 0-9 对应的 P0 引脚数据值
	.db #0b11000000 ; dp 与 g 灭，显示 0
	.db #0b11111001 ; 仅 bc 亮，显示 1
	.db #0b10100100 ; 仅 cf 灭，显示 2
	.db #0b10110000 ; 仅 ef 灭，显示 3
	.db #0b10011001 ; 仅 ade 灭，显示 4
	.db #0b10010010 ; 仅 be 灭，显示 5
	.db #0b10000010 ; 仅 b 灭，显示 6
	.db #0b11111000 ; defg 灭，显示 7
	.db #0b10000000 ; 全部亮，显示 8
	.db #0b10010000 ; 仅 e 灭，显示 9

;------------------------------------------------------------
; function 'delay'
; 此处延时的工作原理：让单片机重复执行非常多次 djnz 指令，实现延时效果
; 时长计算方法：
;  1. mov 指令耗时一个机器周期，但是它跑得比较少可以直接忽略
;  2. djnz 指令耗时两个机器周期，它主要的执行次数为 r0 * 0xff 次
;  3. 因为使用的是 12M 的晶振，经过 51 单片机内部 12 分频
;（即脉冲变宽，频率为晶振频率的十二分之一）后为 1M，那么一个机器周期的时间是 1 微秒
; 这样就能得出当 r0 为 0xff 时，每次延时时间略大于 2 * 0xff * 0xff 微秒，约为 0.13 秒
;------------------------------------------------------------
_delay:
	mov r0, #0x20       ; 将 0x20 赋到 r0 上
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret  ; 出栈之前保存的地址到程序指针 PC，从而跳转回原来的地方继续执行
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)
```
