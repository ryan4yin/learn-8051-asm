# 汇编

与 keli 不同，sdcc 的汇编带了挺多 .area 相关的内容，不然编译会出问题。

我直接写了个最简 c 函数编译得到了 sdcc 的 asm 模版，然后在这个模板的基础上改自己的代码...

platformio 的自动上传指令有错，手动上传命令：

```
stcgal -P stc89 -p /dev/ttyUSB0 -t 11059 .pio/build/Generic8051/firmware.hex
```

上传时需要通过手动插拔 vcc 引脚线实现芯片复位。

51 单片机自学笔记的第一个汇编程序，改造成 sdcc 兼容格式后内容为（省略掉了 sdcc 的 asm 模板内容）：

```assembly
; ......省略若干 sdcc 的模板汇编内容
;--------------------------------------------------------
; Home
;--------------------------------------------------------
	.area HOME    (CODE)
	.area HOME    (CODE)
__sdcc_program_startup:
	ljmp	_main
;	return from main will return to caller
;--------------------------------------------------------
; code
;--------------------------------------------------------
	.area CSEG    (CODE)
;------------------------------------------------------------
;	 function main
;	-----------------------------------------
_main:
	ar7 = 0x07
	ar6 = 0x06
	ar5 = 0x05
	ar4 = 0x04
	ar3 = 0x03
	ar2 = 0x02
	ar1 = 0x01
	ar0 = 0x00
_main_loop:
	clr     _P0_7       ; P0.7 置低电平，灯亮
	; call/scall 都仅能用于跳转到当前代码块的 label，为了跳转到外部代码块，这里必须用 lcall
	; lcall 的工作方式：首先将程序计数器 PC 当前值压栈，然后将 PC 设为目标地址再开始执行程序。等目标代码段执行完毕后再出栈恢复旧 PC 
	lcall   _delay      ; 调用延时程序  
	setb    _P0_7       ; P0.7 置高电平，灯灭
	lcall   _delay
	sjmp    _main_loop  ; 无限循环 
;------------------------------------------------------------
; function 'delay'
;------------------------------------------------------------
_delay:
	mov r0, #0xff       ; 赋值为 #0xff 也就是 255
	_d2:
		mov	r1, #0xff   ; 赋值为 #0xff 也就是 255
	_d1:
		djnz r1, _d1    ; R1 减 1 不等于 0 跳到 _d1 处
		djnz r0, _d2    ; R0 减 1 不等于 0 跳到 _d2 处
		jnc	_return

;------------------------------------------------------------
; _return 程序最终退出的地方
; 这其中的 .area 也是 sdcc 模板内容的一部分
;------------------------------------------------------------
_return:
	ret
	.area CSEG    (CODE)
	.area CONST   (CODE)
	.area XINIT   (CODE)
	.area CABS    (ABS,CODE)

```